---
tags: [ethereum, keys, account, cryptography]
aliases: [Key Generation, 帳戶創建, 密鑰對生成]
---

# 密鑰生成與帳戶創建

## 概述

與傳統銀行不同，Ethereum 不需要任何人幫你「開戶」——你自己就是銀行。只要在本機產生一組隨機數字（私鑰），就能透過數學運算推導出公鑰和地址，完成帳戶創建。整個過程離線完成，不需要連上任何伺服器。

想像你要收朋友轉來的 ETH：你先用錢包產生一個帳戶，拿到一串 `0x...` 開頭的地址，把它貼給朋友就行了。這個地址背後的密鑰對（私鑰 + 公鑰）是用密碼學安全的隨機數產生器（[[CSPRNG]]）和 [[secp256k1]] 橢圓曲線計算出來的，再經 [[Keccak-256]] 雜湊得到地址。

本文涵蓋私鑰生成的安全要求、公鑰推導的數學原理、地址格式（EIP-55 校驗），以及 EOA 與合約帳戶的區別。

## 核心原理

### 私鑰生成

私鑰 $k$ 是一個 256-bit 整數，滿足：

$$1 \leq k < n$$

其中 $n$ 是 [[secp256k1]] 曲線的階（order）：

$$n = \texttt{0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141}$$

約為 $2^{256} - 4.3 \times 10^{38}$。私鑰必須由 [[CSPRNG]] 產生，使用 `Math.random()` 或弱隨機源將導致私鑰可預測。

### 公鑰推導

公鑰 $K$ 透過橢圓曲線標量乘法計算：

$$K = k \cdot G$$

其中 $G$ 是 [[secp256k1]] 的生成點（generator point）。結果是曲線上一個點 $(x, y)$，非壓縮格式為 65 bytes：

$$K_{uncompressed} = \texttt{0x04} \| x \| y$$

前綴 `0x04` 表示非壓縮格式。壓縮格式為 33 bytes，只保留 $x$ 和 $y$ 的奇偶性。

Ethereum 使用非壓縮公鑰（去掉 `0x04` 前綴的 64 bytes）進行地址推導。

### 地址推導

```
地址 = Keccak-256(公鑰的 64 bytes)[12:32]
```

即取 [[Keccak-256]] 雜湊輸出的最後 20 bytes（160 bits）。這意味著：

1. 地址空間為 $2^{160}$，碰撞機率極低（生日攻擊需 $\approx 2^{80}$ 次嘗試）
2. 從地址無法反推公鑰（雜湊的單向性）
3. 公鑰在第一次發送交易前不會上鏈 -- 只有地址可見

流程圖：

```
CSPRNG → 私鑰(32B) → secp256k1 → 公鑰(64B) → Keccak-256 → 取後 20B → 地址(20B)
                                                                           ↓
                                                              EIP-55 checksum encoding
```

### EIP-55 地址校驗

[[EIP-55 地址校驗]] 在地址的十六進位表示中混合大小寫作為 checksum。對地址的小寫 hex 取 Keccak-256，若雜湊的第 $i$ 個半位元組 $\geq 8$，則地址第 $i$ 個字元大寫。這提供了約 99.986% 的錯誤偵測率。

## 在 Ethereum 中的應用

- **[[EOA]]**：外部擁有帳戶由密鑰對控制，私鑰 = 完全控制權
- **[[合約帳戶]]**：地址由 deployer 地址和 nonce 計算（`CREATE`）或由 deployer、salt、init code 計算（`CREATE2`），不涉及密鑰對
- **[[地址推導]]**：EOA 用上述流程；合約用 `Keccak-256(RLP([sender, nonce]))[12:32]`
- **HD Wallet（BIP-32/44）**：從單一 seed 推導出樹狀結構的密鑰對，Ethereum 路徑為 `m/44'/60'/0'/0/index`

## 程式碼範例

```javascript
import { ethers } from 'ethers';

// --- 方法 1：隨機產生新錢包 ---
const wallet = ethers.Wallet.createRandom();
console.log('Address:', wallet.address);
console.log('Private Key:', wallet.privateKey);
console.log('Public Key:', wallet.publicKey); // 壓縮格式 (33 bytes)
console.log('Mnemonic:', wallet.mnemonic.phrase);

// --- 方法 2：從私鑰建立 ---
const privateKey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
const wallet2 = new ethers.Wallet(privateKey);

// --- 方法 3：手動推導地址 ---
// 從私鑰推導非壓縮公鑰
const signingKey = new ethers.SigningKey(privateKey);
const publicKeyUncompressed = signingKey.publicKey; // 0x04 + 64 bytes

// 移除 0x04 前綴，取 Keccak-256 後 20 bytes
const publicKeyBytes = publicKeyUncompressed.slice(4); // 去掉 "0x04"
const hash = ethers.keccak256('0x' + publicKeyBytes);
const address = '0x' + hash.slice(-40); // 後 20 bytes = 40 hex chars
console.log('Derived Address:', ethers.getAddress(address)); // EIP-55 checksum

// --- 方法 4：HD Wallet 推導 ---
const mnemonic = 'test test test test test test test test test test test junk';
const hdNode = ethers.HDNodeWallet.fromPhrase(mnemonic);
// Ethereum 標準路徑 m/44'/60'/0'/0/0
const child = hdNode.derivePath("m/44'/60'/0'/0/0");
console.log('HD Address:', child.address);

// --- 驗證地址格式 ---
console.log('Is valid address:', ethers.isAddress('0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'));
```

## 安全注意事項

- 私鑰一旦洩露，帳戶資產無法挽回。沒有「重設密碼」機制
- 不要使用弱隨機源（browser `Math.random()`、可預測的 seed）
- 私鑰的 entropy 需要完整的 256 bits；brain wallet（用密碼雜湊當私鑰）已被證明不安全
- 硬體錢包讓私鑰永遠不離開安全晶片，是目前最佳實踐

## 相關概念

- [[交易生命週期]] - 本筆記是流程第一步
- [[CSPRNG]] - 私鑰的隨機數來源
- [[secp256k1]] - 公鑰推導使用的橢圓曲線
- [[Keccak-256]] - 地址推導的雜湊函數
- [[橢圓曲線密碼學]] - ECC 數學基礎
- [[公鑰密碼學]] - 非對稱加密通用概念
- [[地址推導]] - 完整的地址推導規格
- [[EIP-55 地址校驗]] - 地址的 checksum 編碼
- [[EOA]] - 由密鑰對控制的帳戶類型
- [[交易構建]] - 流程下一步
