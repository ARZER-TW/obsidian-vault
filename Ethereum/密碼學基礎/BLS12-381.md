---
tags: [ethereum, cryptography, elliptic-curve, BLS12-381, pairing]
aliases: [BLS12381, BLS12-381 curve]
---

# BLS12-381

## 概述

BLS12-381 是 Ethereum 共識層（[[Beacon Chain]]）使用的 pairing-friendly 橢圓曲線。「BLS」指 Barreto-Lynn-Scott 構造，「12」是 embedding degree，「381」是基域質數的位元數。它支援雙線性配對（bilinear pairing）運算，使 [[BLS Signatures]] 的聚合簽名成為可能，也是 [[KZG Commitments]] 和 [[zkSNARKs 支援]] 的基礎。

## 核心原理

### 曲線方程

BLS12-381 實際上是一對曲線：

**$G_1$（定義在 $\mathbb{F}_p$ 上）：**

$$E_1: y^2 = x^3 + 4$$

**$G_2$（定義在 $\mathbb{F}_{p^2}$ 上）：**

$$E_2: y^2 = x^3 + 4(1 + i)$$

其中 $\mathbb{F}_{p^2} = \mathbb{F}_p[i] / (i^2 + 1)$，即 $\mathbb{F}_p$ 的二次擴展域。

### 域參數

**基域質數 $p$（381 bit）：**

$$p = \texttt{0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab}$$

$p$ 的特殊形式：$p = (x - 1)^2 \cdot (x^4 - x^2 + 1) / 3 + x$，其中 $x = -\texttt{0xd201000000010000}$。

**子群的階 $r$（255 bit）：**

$$r = \texttt{0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001}$$

$r$ 是質數，$r = x^4 - x^2 + 1$。

**Embedding degree**：$k = 12$

這意味著配對的目標群 $G_T$ 定義在 $\mathbb{F}_{p^{12}}$ 上。$k = 12$ 是安全性和效率的平衡——足夠大以抵抗 MOV attack，又不至於太大導致配對運算過慢。

### 雙線性配對（Bilinear Pairing）

核心運算 $e: G_1 \times G_2 \rightarrow G_T$，滿足：

**雙線性（Bilinearity）：**

$$e(aP, bQ) = e(P, Q)^{ab}$$

$$e(P + R, Q) = e(P, Q) \cdot e(R, Q)$$

$$e(P, Q + S) = e(P, Q) \cdot e(P, S)$$

**非退化（Non-degeneracy）：**

$$e(G_1, G_2) \neq 1_{G_T}$$

其中 $G_1, G_2$ 分別是 $G_1, G_2$ 的生成元。

**可計算性**：存在高效算法（Optimal Ate pairing）。

### 三個群

| 群 | 定義域 | 元素大小 | 用途 |
|----|--------|----------|------|
| $G_1$ | $E_1(\mathbb{F}_p)$ | 48 bytes（壓縮） | 公鑰或簽名（取決於方案） |
| $G_2$ | $E_2(\mathbb{F}_{p^2})$ | 96 bytes（壓縮） | 簽名或公鑰 |
| $G_T$ | $\mathbb{F}_{p^{12}}^*$ | 576 bytes | 配對結果 |

Ethereum 的 [[BLS Signatures]] 選擇公鑰在 $G_1$（48 bytes），簽名在 $G_2$（96 bytes），因為 Beacon Chain 需要頻繁聚合公鑰。

### Optimal Ate Pairing

BLS12-381 使用 Optimal Ate pairing，計算流程：

1. **Miller Loop**：沿著 $x = -\texttt{0xd201000000010000}$ 的 binary representation 做 double-and-add，累積中間值
2. **Final Exponentiation**：將 Miller Loop 的結果做 $(p^{12} - 1) / r$ 次冪，映射到 $G_T$ 的唯一代表

### 安全強度

BLS12-381 的設計目標是 128-bit 安全：

- ECDLP in $G_1$：$\approx 2^{128}$（Pollard's rho）
- ECDLP in $G_2$：$\approx 2^{128}$
- DLP in $G_T$（NFS in $\mathbb{F}_{p^{12}}$）：$\approx 2^{128}$

$p$ 選 381 bit（而非 256 bit）就是為了讓 $G_T$ 中的 NFS 攻擊也達到 128-bit 安全。

### 與 BN254 的比較

| | BN254 | BLS12-381 |
|--|-------|-----------|
| 基域 | 254 bit | 381 bit |
| 安全強度 | ~100 bit | ~128 bit |
| EVM precompile | 有（0x06-0x08） | 提案中（EIP-2537） |
| 用途 | 舊版 zkSNARK | Beacon Chain, KZG, 新 precompile |

BN254（alt_bn128）因安全強度不足，逐漸被 BLS12-381 取代。自 Pectra 升級後，EVM 已原生支援 BLS12-381 操作。

## 在 Ethereum 中的應用

- **[[BLS Signatures]]**：[[Validators]] 使用 BLS 簽名進行 [[Attestation]]，簽名可聚合以降低頻寬和驗證成本
- **[[KZG Commitments]]**：[[EIP-4844 Proto-Danksharding]] 使用 BLS12-381 上的 KZG 多項式承諾
- **Trusted Setup**：KZG 需要 structured reference string（SRS），基於 BLS12-381 的 $G_1, G_2$ 點
- **[[RANDAO]]**：使用 BLS 簽名的確定性特性來混合隨機性

### EIP-2537 預編譯合約（Pectra 2025/5/7 上線）

EIP-2537 是 BLS12-381 在 Ethereum 執行層的里程碑——在提案多年後終於在 Pectra 升級正式上線。新增 9 個 [[Precompiled Contracts]]，地址 0x0B 至 0x13：

| 地址 | 操作 | Gas Cost | 說明 |
|------|------|----------|------|
| `0x0B` | G1Add | 375 | $G_1$ 點加法 |
| `0x0C` | G1Mul | 12000 | $G_1$ 純量乘法 |
| `0x0D` | G1MultiExp | 動態 | $G_1$ multi-scalar multiplication |
| `0x0E` | G2Add | 600 | $G_2$ 點加法 |
| `0x0F` | G2Mul | 22500 | $G_2$ 純量乘法 |
| `0x10` | G2MultiExp | 動態 | $G_2$ multi-scalar multiplication |
| `0x11` | Pairing | 動態 | bilinear pairing 驗證 |
| `0x12` | MapToG1 | 5500 | field element 映射到 $G_1$ |
| `0x13` | MapToG2 | 23800 | field element 映射到 $G_2$ |

**輸入格式**：$G_1$ 點使用 128 bytes（x, y 各 64 bytes，zero-padded），$G_2$ 點使用 256 bytes。標量為 32 bytes（little-endian）。

**意義**：
- 執行層終於可以原生驗證共識層的 BLS 簽名
- [[zkSNARKs 支援]] 可以遷移到更安全的 BLS12-381 曲線
- 跨鏈橋、輕客戶端合約等應用有了更強的密碼學基礎
- 與 BN254 precompile（0x06-0x08）並存，向後相容

## 程式碼範例

```python
# 使用 py_ecc 庫操作 BLS12-381
from py_ecc.bls import G2ProofOfPossession as bls
from py_ecc.bls.g2_primitives import G1_to_pubkey, pubkey_to_G1
from py_ecc.optimized_bls12_381 import (
    G1, G2, Z1, Z2,
    multiply, add, pairing, neg,
    curve_order,
)

# === 基本群運算 ===
# G1 生成元的純量乘法
P = multiply(G1, 42)
Q = multiply(G1, 58)
R = add(P, Q)
R_direct = multiply(G1, 100)
# R == R_direct（42G + 58G = 100G）

# === 驗證雙線性性質 ===
a = 3
b = 5

# e(aG1, bG2) == e(G1, G2)^(ab) == e(abG1, G2) == e(G1, abG2)
lhs = pairing(multiply(G2, b), multiply(G1, a))
rhs = pairing(multiply(G2, a * b), G1)
assert lhs == rhs
print("[OK] Bilinearity: e(aG1, bG2) == e(abG1, G2)")

# === BLS 簽名（Ethereum 共識層使用的方案）===
import secrets

# 金鑰生成
private_key = secrets.token_bytes(32)
public_key = bls.SkToPk(private_key)
print(f"Public key (48 bytes): {public_key.hex()[:32]}...")

# 簽名
message = b"attestation data"
signature = bls.Sign(private_key, message)
print(f"Signature (96 bytes): {signature.hex()[:32]}...")

# 驗證
is_valid = bls.Verify(public_key, message, signature)
print(f"Signature valid: {is_valid}")

# === 聚合簽名 ===
# 模擬多個 validator
num_validators = 5
keys = [secrets.token_bytes(32) for _ in range(num_validators)]
pubkeys = [bls.SkToPk(k) for k in keys]
signatures = [bls.Sign(k, message) for k in keys]

# 聚合
agg_signature = bls.Aggregate(signatures)
print(f"Aggregated signature: {agg_signature.hex()[:32]}...")

# 驗證聚合簽名
is_valid = bls.AggregateVerify(pubkeys, [message] * num_validators, agg_signature)
print(f"Aggregate verification: {is_valid}")
```

## 相關概念

- [[橢圓曲線密碼學]] - ECC 的通用原理
- [[secp256k1]] - 執行層使用的曲線（非 pairing-friendly）
- [[BLS Signatures]] - 基於 BLS12-381 配對的簽章方案
- [[KZG Commitments]] - 基於 BLS12-381 的多項式承諾
- [[EIP-4844 Proto-Danksharding]] - 使用 KZG 承諾的 data blob
- [[Beacon Chain]] - 使用 BLS12-381 的共識層
- [[Validators]] - 使用 BLS 金鑰進行簽名
- [[Attestation]] - validator 用 BLS 簽署的投票
- [[RANDAO]] - 利用 BLS 簽名的確定性
- [[zkSNARKs 支援]] - 使用配對的零知識證明
- [[Precompiled Contracts]] - BN254 precompile（0x06-0x08）與 BLS12-381 precompile（0x0B-0x13，Pectra 上線）
