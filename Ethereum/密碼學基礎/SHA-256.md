---
tags: [ethereum, cryptography, hash-function, sha256]
aliases: [SHA256, SHA-2]
---

# SHA-256

## 概述

SHA-256（Secure Hash Algorithm 256-bit）是 SHA-2 家族的成員，由 NSA 設計、NIST 標準化。在 Ethereum 生態中，SHA-256 主要用於 [[Beacon Chain]] 共識層和 [[Precompiled Contracts]]（地址 0x02），而執行層以 [[Keccak-256]] 為主。

## 核心原理

### Merkle-Damgard 結構

SHA-256 採用 Merkle-Damgard 迭代結構：

1. **填充**：訊息末尾加 `1` bit，再加 $0$ bits 使總長度 $\equiv 448 \pmod{512}$，最後附 64-bit 原始訊息長度
2. **分區塊**：填充後的訊息切為 512-bit 區塊 $M_1, M_2, \ldots, M_N$
3. **壓縮**：從初始向量 $H_0$ 開始，逐區塊壓縮：$H_i = H_{i-1} + \text{Compress}(H_{i-1}, M_i)$

### 初始向量

8 個 32-bit 常數，取自前 8 個質數之平方根的小數部分：

$$H_0^{(0)} = \texttt{6a09e667}, \quad H_1^{(0)} = \texttt{bb67ae85}, \quad \ldots$$

### 壓縮函數

每個 512-bit 區塊經過 64 輪運算。核心邏輯：

**Message Schedule**（將 16 個 32-bit word 擴展為 64 個）：

$$W_t = \begin{cases} M_t & 0 \le t \le 15 \\ \sigma_1(W_{t-2}) + W_{t-7} + \sigma_0(W_{t-15}) + W_{t-16} & 16 \le t \le 63 \end{cases}$$

其中小 sigma 函數：

$$\sigma_0(x) = \text{ROTR}^7(x) \oplus \text{ROTR}^{18}(x) \oplus \text{SHR}^3(x)$$
$$\sigma_1(x) = \text{ROTR}^{17}(x) \oplus \text{ROTR}^{19}(x) \oplus \text{SHR}^{10}(x)$$

**每輪更新**（使用 8 個工作變數 $a$ 到 $h$）：

$$T_1 = h + \Sigma_1(e) + \text{Ch}(e,f,g) + K_t + W_t$$
$$T_2 = \Sigma_0(a) + \text{Maj}(a,b,c)$$

其中：

$$\Sigma_0(a) = \text{ROTR}^2(a) \oplus \text{ROTR}^{13}(a) \oplus \text{ROTR}^{22}(a)$$
$$\Sigma_1(e) = \text{ROTR}^6(e) \oplus \text{ROTR}^{11}(e) \oplus \text{ROTR}^{25}(e)$$
$$\text{Ch}(e,f,g) = (e \land f) \oplus (\lnot e \land g)$$
$$\text{Maj}(a,b,c) = (a \land b) \oplus (a \land c) \oplus (b \land c)$$

### 安全性

- 輸出：256 bit
- Preimage resistance：$O(2^{256})$
- Collision resistance：$O(2^{128})$
- 已知弱點：**Length Extension Attack**——知道 $H(m)$ 和 $|m|$ 可偽造 $H(m \| \text{padding} \| m')$，無需知道 $m$

## 在 Ethereum 中的應用

### Precompiled Contract

地址 `0x0000000000000000000000000000000000000002` 提供 SHA-256 precompile：

- Gas：$60 + 12 \times \lceil \text{len}/32 \rceil$
- 比 [[Keccak-256]] 的 EVM opcode 貴一倍
- 主要用於與 Bitcoin 等系統的互操作

### Beacon Chain（共識層）

- [[Beacon Chain]] 的 [[SSZ 編碼]] 使用 SHA-256 作為 Merkleization 的雜湊函數
- [[RANDAO]] 混合隨機性時使用 SHA-256
- Validator 的 deposit 資料雜湊使用 SHA-256
- 選擇 SHA-256 而非 Keccak-256 的原因：硬體加速支援（Intel SHA Extensions）更成熟

### 與 Bitcoin 的橋接

BTC relay、跨鏈驗證等場景需要在 EVM 中驗證 Bitcoin 的 double-SHA-256（`SHA-256(SHA-256(data))`），此時 precompile 就很必要。

## 程式碼範例

```python
import hashlib
import struct

# 基本 SHA-256
msg = b"ethereum"
h = hashlib.sha256(msg).hexdigest()
print(f"SHA-256('ethereum') = {h}")

# Double SHA-256（Bitcoin 風格）
def double_sha256(data: bytes) -> bytes:
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

print(f"Double SHA-256: {double_sha256(b'bitcoin').hex()}")

# 演示 Length Extension Attack 的概念
# 假設已知 H(secret || msg) 和 msg 長度，可以構造 H(secret || msg || padding || ext)
# 這在 HMAC 設計中是重要考量

# SHA-256 vs Keccak-256
from Crypto.Hash import keccak

data = b"test"
sha256_result = hashlib.sha256(data).hexdigest()
k = keccak.new(digest_bits=256)
k.update(data)
keccak_result = k.hexdigest()

print(f"SHA-256:    {sha256_result}")
print(f"Keccak-256: {keccak_result}")

# Beacon Chain SSZ Merkleization 簡化示意
def merkleize(chunks: list[bytes]) -> bytes:
    """簡化版 SSZ Merkleization"""
    # 補齊至 2 的冪次
    layer = list(chunks)
    while len(layer) & (len(layer) - 1):
        layer.append(b'\x00' * 32)

    while len(layer) > 1:
        next_layer = []
        for i in range(0, len(layer), 2):
            combined = layer[i] + layer[i + 1]
            next_layer.append(hashlib.sha256(combined).digest())
        layer = next_layer

    return layer[0]

chunks = [hashlib.sha256(f"chunk{i}".encode()).digest() for i in range(4)]
root = merkleize(chunks)
print(f"Merkle root: {root.hex()}")
```

## 相關概念

- [[雜湊函數概述]] - 雜湊函數的安全性質總覽
- [[Keccak-256]] - Ethereum 執行層使用的雜湊函數
- [[Beacon Chain]] - 共識層使用 SHA-256
- [[SSZ 編碼]] - 使用 SHA-256 進行 Merkleization
- [[RANDAO]] - 使用 SHA-256 混合隨機性
- [[Precompiled Contracts]] - SHA-256 作為 precompile 地址 0x02
- [[Merkle Tree]] - SHA-256 是常用的雜湊函數選項
