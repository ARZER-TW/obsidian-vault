---
tags: [ethereum, cryptography, polynomial-commitment, kzg, ipa, verkle]
aliases: [Polynomial Commitment, 多項式承諾, Polynomial Commitment Scheme]
---

# 多項式承諾入門

## 為什麼需要多項式承諾

考慮一個場景：Alice 有一組資料 $[v_0, v_1, ..., v_{n-1}]$，她想公開一個簡短的「摘要」，之後能證明資料中任意位置 $i$ 的值是 $v_i$，而不需要揭露整組資料。

傳統做法是 Merkle Tree：對資料建樹，公開 root hash，提供 $O(\log n)$ 大小的 proof。這夠好，但 proof 隨資料量對數成長。

多項式承諾（polynomial commitment scheme）提供更強的方案：proof 大小固定，與資料量無關。

## 核心直覺

任何一組 $n$ 個值都可以用一條 degree $n-1$ 的多項式表示。把資料 $[v_0, v_1, ..., v_{n-1}]$ 編碼為多項式 $p(x)$，使得 $p(i) = v_i$（透過 Lagrange 插值）。

多項式承諾就是對這條多項式的「指紋」，具備三個性質：

- **Binding**：不同多項式產生不同承諾（不可偽造）
- **Hiding**：從承諾無法反推多項式（隱私保護）
- **簡潔**：承諾大小固定，與多項式 degree 無關

## 三步驟流程

**Step 1 -- Commit（承諾）**

Prover 將多項式 $p(x)$ 壓縮為一個固定大小的承諾 $C$：

$$C = \text{Commit}(p)$$

$C$ 公開發布，此後 prover 不能更換底層多項式。

**Step 2 -- Open（開啟）**

Prover 要證明 $p(z) = y$，計算一個 opening proof $\pi$：

$$\pi = \text{Open}(p, z)$$

直覺：如果 $p(z) = y$，則 $(x - z)$ 整除 $p(x) - y$，商多項式 $q(x) = \frac{p(x) - y}{x - z}$ 存在。Proof 就是對 $q(x)$ 的承諾。

**Step 3 -- Verify（驗證）**

Verifier 只需要 $C$、$z$、$y$、$\pi$，不需要知道 $p(x)$：

$$\text{Verify}(C, z, y, \pi) \stackrel{?}{=} \text{true}$$

驗證速度與多項式 degree 無關。

## 數值例子

資料 $[3, 7, 15]$ 對應三個點 $(0, 3)$, $(1, 7)$, $(2, 15)$。

Lagrange 插值得到 $p(x) = 2x^2 + 2x + 3$：
- $p(0) = 3$
- $p(1) = 2 + 2 + 3 = 7$
- $p(2) = 8 + 4 + 3 = 15$

Prover 發布 $C = \text{Commit}(p)$。之後要證明 $p(1) = 7$：

商多項式 $q(x) = \frac{p(x) - 7}{x - 1} = \frac{2x^2 + 2x - 4}{x - 1} = 2x + 4$

Prover 發送 $\pi = \text{Commit}(q)$。Verifier 檢查承諾之間的代數關係是否成立。

## KZG vs IPA

Ethereum 生態中使用兩種多項式承諾方案：

| 特性 | KZG | IPA |
|------|-----|-----|
| 全稱 | Kate-Zaverucha-Goldberg | Inner Product Argument |
| Trusted setup | 需要（一次性 MPC ceremony） | 不需要 |
| Commitment 大小 | 48 bytes（1 個 $\mathbb{G}_1$ 元素） | 32 bytes（1 個群元素） |
| Proof 大小 | 48 bytes（固定） | ~$\log n$ 個群元素 |
| 驗證時間 | 快（2 次 pairing） | 較慢（$O(n)$ multi-scalar multiplication） |
| 數學基礎 | [[橢圓曲線配對導論|Bilinear pairing]] | Inner product relation |
| 曲線 | [[BLS12-381]] | Bandersnatch |
| 量子安全 | 否 | 否 |

**[[KZG Commitments]]** 用於 blob 驗證（[[EIP-4844 Proto-Danksharding|EIP-4844]]），proof 最小、驗證最快，但需要 trusted setup。Ethereum 在 2023 年完成了超過 141,000 人參與的 KZG Ceremony。

**IPA** 用於 [[Verkle Trees]] 的 state proof，避免 trusted setup 的額外信任假設。搭配 Bandersnatch 曲線（嵌入 BLS12-381 標量域），在 SNARK 電路中驗證效率高。

## 在 Ethereum 中的三個場景

**1. Blob 驗證（The Surge）**
每個 blob 的 4096 個 field element 編碼為多項式，用 KZG 承諾。Point evaluation precompile 讓 L1 合約驗證 blob 中特定位置的值。PeerDAS 用 KZG opening proof 實現資料可用性取樣。

**2. Verkle State Proof（The Verge）**
Verkle Tree 每個節點的 256 個子節點值構成多項式，節點的 hash 是 IPA commitment。Proof 從 Merkle 的 ~3.5 KB 縮減到 ~150 bytes，使 stateless client 成為可能。

**3. zk-SNARK 驗證**
多項式承諾是大多數 SNARK 系統的核心組件。Groth16 用 KZG 風格的 commitment，PLONK 和 Halo2 可選用 KZG 或 IPA。L2 ZK Rollup 的 validity proof 最終都依賴某種形式的多項式承諾。

## 下一步

理解多項式承諾的流程後，進入具體方案：
- [[橢圓曲線配對導論]] -- 理解 KZG 驗證為什麼只需要 2 次 pairing
- [[KZG Commitments]] -- 完整的 KZG 數學推導和 Ethereum 應用
- [[Verkle Trees]] -- IPA 在狀態管理中的應用

## 相關概念

- [[KZG Commitments]] - KZG 方案的完整推導
- [[Verkle Trees]] - IPA 方案在 state trie 中的應用
- [[EIP-4844 Proto-Danksharding]] - Blob 用 KZG commitment 承諾
- [[橢圓曲線配對導論]] - KZG 驗證的數學基礎
- [[BLS12-381]] - KZG 使用的 pairing-friendly 曲線
- [[zkSNARKs 支援]] - 多項式承諾在 SNARK 中的角色
- [[Ethereum 擴展性路線圖]] - 多項式承諾在路線圖中的位置
