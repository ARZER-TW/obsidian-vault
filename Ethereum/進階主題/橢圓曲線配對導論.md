---
tags: [ethereum, cryptography, elliptic-curve, pairing, bls12-381]
aliases: [Elliptic Curve Pairing, Bilinear Pairing, 橢圓曲線配對, Pairing]
---

# 橢圓曲線配對導論

## 前置概念

[[橢圓曲線密碼學]] 定義了曲線上的「加法」：兩點相加得到第三點，重複加同一點 $n$ 次得到標量乘法 $nP$。已知 $P$ 和 $nP$，反推 $n$ 是困難的（離散對數問題，DLP）。這是 ECDSA 和大多數區塊鏈密碼學的安全基礎。

但標量乘法有一個限制：它只在「同一條曲線」上操作。如果 Alice 持有秘密 $a$、Bob 持有秘密 $b$，他們能分別計算 $aP$ 和 $bP$，卻無法在不揭露 $a$ 或 $b$ 的情況下計算出與 $ab$ 相關的值。

橢圓曲線配對（bilinear pairing）解決了這個問題。

## Bilinear Pairing 定義

Pairing 是一個映射：

$$e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$$

輸入是兩個不同橢圓曲線群的點，輸出是目標群 $\mathbb{G}_T$ 的元素。

## 關鍵性質

**雙線性（Bilinearity）**：

$$e(aP, bQ) = e(P, Q)^{ab}$$

等價形式：
- $e(P + P', Q) = e(P, Q) \cdot e(P', Q)$
- $e(P, Q + Q') = e(P, Q) \cdot e(P, Q')$

直覺：pairing 把兩個群中的「標量乘法」轉化為目標群中的「指數乘法」。兩個秘密 $a$ 和 $b$ 分別藏在 $\mathbb{G}_1$ 和 $\mathbb{G}_2$ 的點裡，pairing 在目標群中把它們「混合」起來，產生一個與 $ab$ 相關的值，但不揭露 $a$ 或 $b$。

**非退化性（Non-degeneracy）**：如果 $P \neq 0$ 且 $Q \neq 0$，則 $e(P, Q) \neq 1_{\mathbb{G}_T}$。Pairing 的輸出攜帶有意義的資訊。

## BLS12-381 的三個群

Ethereum 使用 [[BLS12-381]] 曲線，它提供高效的 pairing 運算：

| 群 | 元素大小 | 角色 |
|----|---------|------|
| $\mathbb{G}_1$ | 48 bytes | 較小的群，commitment 和 proof 通常放在這裡 |
| $\mathbb{G}_2$ | 96 bytes | 較大的群，trusted setup 參數的一部分 |
| $\mathbb{G}_T$ | 576 bytes | 目標群，pairing 的輸出，用於等式檢查 |

三個群的 order 相同（都是 $r \approx 2^{255}$），但底層數學結構不同：$\mathbb{G}_1$ 定義在基域 $\mathbb{F}_p$ 上，$\mathbb{G}_2$ 定義在擴展域 $\mathbb{F}_{p^2}$ 上，$\mathbb{G}_T$ 是 $\mathbb{F}_{p^{12}}$ 的子群。

## 應用一：KZG 驗證

[[KZG Commitments]] 的驗證核心是一個 pairing 等式。要驗證 $p(z) = y$：

$$e(\pi, [\tau - z]_2) = e(C - [y]_1, [1]_2)$$

展開後利用雙線性：

$$e(g_1, g_2)^{q(\tau)(\tau - z)} = e(g_1, g_2)^{p(\tau) - y}$$

即 $q(\tau) \cdot (\tau - z) = p(\tau) - y$，正是多項式除法定理在 $x = \tau$ 處的等式。

Pairing 讓驗證者在不知道 $\tau$（已銷毀的 toxic waste）的情況下，檢查 commitment 之間的代數關係。這是 KZG 能「檢查多項式」的根本原因：pairing 把 $\mathbb{G}_1$ 中的承諾和 $\mathbb{G}_2$ 中的 setup 參數連結起來，在 $\mathbb{G}_T$ 中比較結果。

## 應用二：BLS 簽名聚合

[[BLS Signatures]] 用 pairing 實現簽名聚合。$n$ 個 validator 的簽名 $\sigma_1, ..., \sigma_n$ 可以合併為單一簽名 $\sigma_{agg} = \sigma_1 + ... + \sigma_n$，驗證只需：

$$e(\sigma_{agg}, g_2) = e(H(m), pk_1 + ... + pk_n)$$

一次 pairing 驗證取代 $n$ 次獨立驗證。Ethereum 的 [[Beacon Chain]] 每個 slot 需要聚合數千個 attestation 簽名，pairing 讓這在計算上可行。

## 應用三：Groth16 驗證

Groth16 是 ZK Rollup 常用的 SNARK 系統。驗證者檢查三個 pairing 的乘積：

$$e(A, B) = e(\alpha, \beta) \cdot e(\sum L_i \cdot x_i, \gamma) \cdot e(C, \delta)$$

這個等式同時驗證了 prover 知道滿足電路約束的 witness。L1 上的 [[Precompiled Contracts]]（地址 `0x08`）提供高效的 BN254 pairing 運算，讓 ZK Rollup 的 on-chain 驗證成本控制在約 300K gas。

## 為什麼 Pairing 能「檢查多項式」

回到核心問題：普通的橢圓曲線運算只能檢查線性關係（$aP + bQ = cR$）。但多項式驗證涉及乘法關係（$q(x) \cdot (x - z) = p(x) - y$）。

Pairing 提供了一次「受控的乘法」：它在 $\mathbb{G}_T$ 中把兩個 commitment 的值「相乘」。這恰好夠用，因為 KZG 驗證只需要檢查一個乘法等式。

這也解釋了 pairing 的局限性：它只提供一層乘法。更複雜的代數關係需要更複雜的協議（如 Groth16 的多 pairing 組合）。

## 下一步

- [[KZG Commitments]] -- 完整的 KZG 數學推導，包括 trusted setup、commitment、verification
- [[BLS12-381]] -- BLS12-381 曲線的具體參數和群結構
- [[多項式承諾入門]] -- KZG 和 IPA 的整體比較

## 相關概念

- [[橢圓曲線密碼學]] - 橢圓曲線加法和 DLP 的基礎
- [[BLS12-381]] - Ethereum 使用的 pairing-friendly 曲線
- [[KZG Commitments]] - 基於 pairing 的多項式承諾方案
- [[BLS Signatures]] - 基於 pairing 的簽名聚合
- [[zkSNARKs 支援]] - Groth16 驗證中的 pairing
- [[Precompiled Contracts]] - L1 上的 pairing 計算加速
- [[Ethereum 擴展性路線圖]] - 配對在路線圖中的角色
- [[多項式承諾入門]] - 多項式承諾的通用概念
