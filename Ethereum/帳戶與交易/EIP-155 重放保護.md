---
tags: [ethereum, eip-155, replay-protection, transaction, signature]
aliases: [EIP-155, EIP-155 重放保護, Chain ID, Replay Protection, Simple Replay Attack Protection]
---

# EIP-155 重放保護

## 概述

EIP-155 透過將 `chainId` 納入交易簽名，防止跨鏈重放攻擊。在 EIP-155 之前，Ethereum mainnet 上簽署的交易可以在任何 EVM-compatible 鏈（如 Ethereum Classic）上重播。EIP-155 在 2016 年 DAO fork 後引入，是 Spurious Dragon 硬分叉的一部分。

## 核心原理

### 問題背景

2016 年 The DAO hack 導致 Ethereum 硬分叉：
- **ETH**（Ethereum mainnet）：分叉後的主鏈
- **ETC**（Ethereum Classic）：拒絕分叉的原鏈

兩條鏈的帳戶和餘額相同，且交易格式一致。攻擊者可以：
1. 在 ETH 上發送一筆交易
2. 截獲簽名後的交易
3. 在 ETC 上重新廣播 → 成功執行（因為簽名有效）

這就是跨鏈重放攻擊。[[Nonce]] 只防同鏈重放，跨鏈的 nonce 可能恰好匹配。

### EIP-155 的解法

在計算交易 hash（用於簽名）時，加入 `chainId`：

#### Pre-EIP-155 簽名

```
sigHash = keccak256(RLP([nonce, gasPrice, gasLimit, to, value, data]))
(v, r, s) = ECDSA_sign(sigHash, privateKey)
v ∈ {27, 28}
```

#### Post-EIP-155 簽名

```
sigHash = keccak256(RLP([nonce, gasPrice, gasLimit, to, value, data, chainId, 0, 0]))
(v, r, s) = ECDSA_sign(sigHash, privateKey)
v = chainId * 2 + 35 + recovery_id
```

關鍵改變：
1. 簽名的 hash 輸入多了 `[chainId, 0, 0]` 三個欄位
2. `v` 值不再是 27/28，而是包含 chainId 資訊

### v 值計算

| 類型 | v 值 |
|------|------|
| Pre-EIP-155 | 27 或 28 |
| Post-EIP-155 | `chainId * 2 + 35` 或 `chainId * 2 + 36` |
| EIP-1559 / EIP-2930 | 0 或 1（`signatureYParity`） |

常見 chainId 對應的 v 值：

| 鏈 | chainId | v 值 |
|----|---------|------|
| Ethereum Mainnet | 1 | 37 或 38 |
| Goerli | 5 | 45 或 46 |
| Sepolia | 11155111 | 22310257 或 22310258 |
| Polygon | 137 | 309 或 310 |
| Arbitrum | 42161 | 84357 或 84358 |

### 從 v 值恢復 chainId

$$\text{chainId} = \frac{v - 35}{2}$$

（若 v > 36，取整數部分）

### 驗證流程

節點驗證交易時：

1. 從 `v` 值提取 `chainId`
2. 確認 `chainId` 與當前鏈一致
3. 重建 `sigHash = keccak256(RLP([..., chainId, 0, 0]))`
4. 用 [[ECRECOVER]] 從 `(v, r, s)` 恢復公鑰
5. 公鑰推導地址，比對 `from`

如果交易是在 chainId=1 上簽的，拿去 chainId=61（ETC）重播：
- 節點用 chainId=61 重建 sigHash → 不同的 hash
- ECRECOVER 恢復出錯誤的地址 → 驗證失敗

### EIP-2718 之後

EIP-2718 引入 typed transaction 後，新交易類型（Type 1, 2, 3, 4）直接在交易欄位中包含 `chainId`：

```
Type 2 (EIP-1559):
RLP([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList])
```

不再使用 v 值編碼 chainId，而是用 `signatureYParity`（0 或 1）。但本質相同：簽名時 chainId 已包含在 hash 輸入中。

### EIP-7702 與交易簽名（Pectra，2025/5/7）

EIP-7702 引入 Type 4（Set Code）交易，其簽名結構延續 typed transaction 的模式，chainId 直接包含在交易欄位中。

值得注意的是，EIP-7702 的 authorization list 中每個授權項目也包含 `chainId` 欄位，且授權本身需要 EOA 的獨立簽名。這意味著：
- 授權可以限定在特定鏈上生效（指定 chainId）
- 也可以設定 `chainId = 0` 表示跨鏈通用授權
- 跨鏈通用授權不受 EIP-155 重放保護，使用時需注意安全風險

## 在 Ethereum 中的應用

- **所有交易**：現代交易（Type 2）強制包含 chainId
- **[[交易簽名]]**：簽名前將 chainId 納入 hash
- **[[交易廣播與驗證]]**：節點驗證 chainId 匹配
- **多鏈開發**：開發者必須確保 chainId 正確
- **[[ECDSA]]**：v 值的語義改變
- **硬分叉**：每次 fork 新鏈都需要新的 chainId

### 主要 Chain ID 列表

| 鏈 | Chain ID |
|----|----------|
| Ethereum Mainnet | 1 |
| Sepolia Testnet | 11155111 |
| Holesky Testnet | 17000 |
| BNB Smart Chain | 56 |
| Polygon | 137 |
| Arbitrum One | 42161 |
| Optimism | 10 |
| Base | 8453 |
| Avalanche C-Chain | 43114 |

完整列表參考 [chainlist.org](https://chainlist.org)。

## 程式碼範例

### JavaScript（ethers.js）

```javascript
import { Wallet, Transaction, JsonRpcProvider, keccak256, encodeRlp, toBeHex, getBytes } from 'ethers';

const provider = new JsonRpcProvider('https://eth.llamarpc.com');

// 查詢當前鏈的 chainId
const network = await provider.getNetwork();
console.log('chainId:', network.chainId);

// 建立交易並觀察 v 值
const wallet = new Wallet('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80');

// Legacy 交易（會使用 EIP-155 v 值）
const legacyTx = Transaction.from({
  type: 0,
  nonce: 0,
  gasPrice: 20000000000n,
  gasLimit: 21000n,
  to: '0x0000000000000000000000000000000000000001',
  value: 0n,
  data: '0x',
  chainId: 1n,
});

const signedLegacy = wallet.signingKey.sign(legacyTx.unsignedHash);
console.log('legacy v:', signedLegacy.v);  // 27 or 28 (raw)
// EIP-155 encoded v = chainId * 2 + 35 + (v - 27)

// 手動計算 EIP-155 v 值
const chainId = 1n;
const recoveryId = signedLegacy.v === 27 ? 0n : 1n;
const eip155V = chainId * 2n + 35n + recoveryId;
console.log('EIP-155 v:', eip155V); // 37 or 38

// 從 v 值恢復 chainId
function getChainIdFromV(v) {
  if (v === 27 || v === 28) return null; // pre-EIP-155
  return (BigInt(v) - 35n) / 2n;
}

console.log('chainId from v=37:', getChainIdFromV(37));  // 1
console.log('chainId from v=38:', getChainIdFromV(38));  // 1
console.log('chainId from v=309:', getChainIdFromV(309)); // 137 (Polygon)

// EIP-1559 交易（v 值為 0 或 1）
const eip1559Tx = Transaction.from({
  type: 2,
  chainId: 1n,
  nonce: 0,
  maxFeePerGas: 20000000000n,
  maxPriorityFeePerGas: 1000000000n,
  gasLimit: 21000n,
  to: '0x0000000000000000000000000000000000000001',
  value: 0n,
});

const signedEip1559 = wallet.signingKey.sign(eip1559Tx.unsignedHash);
console.log('EIP-1559 yParity:', signedEip1559.yParity); // 0 or 1
```

### Python（web3.py / eth-account）

```python
from web3 import Web3
from eth_account import Account
from eth_utils import keccak
import rlp

w3 = Web3(Web3.HTTPProvider('https://eth.llamarpc.com'))

# 查詢 chainId
chain_id = w3.eth.chain_id
print(f"chainId: {chain_id}")

# 簽署 Legacy 交易（包含 EIP-155）
account = Account.from_key('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80')

tx = {
    'nonce': 0,
    'gasPrice': w3.to_wei(20, 'gwei'),
    'gas': 21000,
    'to': '0x0000000000000000000000000000000000000001',
    'value': 0,
    'data': b'',
    'chainId': 1,
}

signed = account.sign_transaction(tx)
print(f"v: {signed.v}")
print(f"r: {hex(signed.r)}")
print(f"s: {hex(signed.s)}")

# 驗證 v 值包含 chainId
def chain_id_from_v(v: int) -> int | None:
    if v in (27, 28):
        return None  # pre-EIP-155
    return (v - 35) // 2

print(f"chainId from v: {chain_id_from_v(signed.v)}")

# 手動建構 EIP-155 signing data
def eip155_signing_data(nonce, gas_price, gas_limit, to, value, data, chain_id):
    """Pre-image for EIP-155 signing"""
    fields = [
        nonce,
        gas_price,
        gas_limit,
        bytes.fromhex(to[2:]),
        value,
        data,
        chain_id,
        0,  # EIP-155: 空的 r
        0,  # EIP-155: 空的 s
    ]
    return keccak(rlp.encode(fields))

sig_hash = eip155_signing_data(0, 20 * 10**9, 21000,
    '0x0000000000000000000000000000000000000001', 0, b'', 1)
print(f"signing hash: 0x{sig_hash.hex()}")
```

## 相關概念

- [[ECDSA]] - EIP-155 修改了簽名的 v 值語義
- [[ECRECOVER]] - 驗證時用 v 值恢復公鑰
- [[Nonce]] - 防止同鏈重放，EIP-155 防止跨鏈重放
- [[交易簽名]] - EIP-155 改變了簽名的 hash 輸入
- [[交易廣播與驗證]] - 節點驗證 chainId 是否匹配
- [[RLP 編碼]] - 簽名 hash 的輸入使用 RLP 序列化
- [[EIP-1559 費用市場]] - Type 2 交易直接包含 chainId 欄位
- [[Keccak-256]] - 簽名 hash 使用 keccak256
